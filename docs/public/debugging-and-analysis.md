# Debugging & Analysis

Cardigantime provides powerful tools for understanding how your configuration is resolved and debugging issues. This guide covers all the analysis and debugging features available.

## Configuration Generation (`--init-config`)

The `--init-config` option generates a complete configuration file with all default values from your Zod schema.

### Basic Usage

```bash
# Generate config file in default directory
./myapp --init-config

# Generate config file in custom directory  
./myapp --config-directory ./my-config --init-config

# Generate in production directory
./myapp --config-directory /etc/myapp --init-config
```

### What `--init-config` Does

1. **Creates target directory** if it doesn't exist
2. **Generates YAML file** with all default values from your schema
3. **Includes helpful comments** and proper formatting
4. **Prevents overwriting** existing files (shows preview instead)
5. **Validates schema** before generation

### Example Generated File

For a schema like:
```typescript
const ConfigSchema = z.object({
  port: z.number().default(3000),
  host: z.string().default('localhost'),
  database: z.object({
    url: z.string().url(),
    maxConnections: z.number().default(10),
    ssl: z.boolean().default(false),
  }),
  features: z.array(z.string()).default(['auth']),
  debug: z.boolean().default(false),
});
```

Generated file (`config/config.yaml`):
```yaml
# Configuration file generated by Cardigantime
# This file contains default values for your application configuration.
# Modify the values below to customize your application's behavior.

# Server configuration
host: localhost
port: 3000

# Database settings
database:
  maxConnections: 10
  ssl: false
  url: ""

# Application settings
debug: false
features:
  - auth
```

### Handling Existing Files

If a configuration file already exists:

```bash
$ ./myapp --init-config
‚ùå Configuration file already exists: ./config/config.yaml

Would generate the following configuration:

# Configuration file generated by Cardigantime
# ... (preview of what would be generated)

üí° Delete the existing file or use a different directory to generate a new configuration.
```

### Programmatic Usage

```typescript
// Generate config file programmatically
await cardigantime.generateConfig('./production-config');

// Generate in default directory
await cardigantime.generateConfig();
```

## Configuration Source Analysis (`--check-config`)

The `--check-config` option provides a git blame-like view of your configuration, showing exactly which file and hierarchical level contributed each configuration value.

### Basic Usage

```bash
# Analyze configuration with source tracking
./myapp --check-config

# Analyze with custom config directory
./myapp --config-directory ./prod-config --check-config

# Analyze hierarchical configuration
./myapp --config-directory .myapp --check-config
```

### Example Output

#### Single Configuration File

```
================================================================================
CONFIGURATION SOURCE ANALYSIS
================================================================================

DISCOVERED CONFIGURATION HIERARCHY:
  Single configuration file: /project/config/config.yaml

RESOLVED CONFIGURATION WITH SOURCES:
Format: [Source] key: value

[config.yaml             ] host                : "localhost"
[config.yaml             ] port                : 8080
[config.yaml             ] database.url        : "postgres://localhost/myapp"
[config.yaml             ] database.ssl        : true
[Schema default          ] database.maxConnections : 10
[Schema default          ] debug               : false
[Schema default          ] features            : ["auth"]

--------------------------------------------------------------------------------
SUMMARY:
  Total configuration keys: 7
  Configuration sources: 2
  Values by source:
    config.yaml: 4 value(s)
    Schema default: 3 value(s)
================================================================================
```

#### Hierarchical Configuration

```
================================================================================
CONFIGURATION SOURCE ANALYSIS
================================================================================

DISCOVERED CONFIGURATION HIERARCHY:
  Level 0: /project/team/myproject/.myapp (highest precedence)
  Level 1: /project/team/.myapp (medium precedence)
  Level 2: /project/.myapp (lowest precedence)

RESOLVED CONFIGURATION WITH SOURCES:
Format: [Source] key: value

[Level 0: myproject      ] host                : "dev.localhost"
[Level 2: project        ] port                : 3000
[Level 1: team           ] database.url        : "postgres://team.db/myapp"
[Level 0: myproject      ] database.ssl        : false
[CLI argument            ] database.maxConnections : 20
[Level 1: team           ] features            : ["auth", "analytics", "logging"]
[Level 0: myproject      ] debug               : true

--------------------------------------------------------------------------------
SUMMARY:
  Total configuration keys: 7
  Configuration sources: 4
  Values by source:
    Level 0: myproject: 3 value(s)
    Level 1: team: 2 value(s)
    Level 2: project: 1 value(s)
    CLI argument: 1 value(s)
================================================================================
```

#### With Array Overlap Configuration

When using custom `fieldOverlaps`:

```
================================================================================
CONFIGURATION SOURCE ANALYSIS
================================================================================

DISCOVERED CONFIGURATION HIERARCHY:
  Level 0: /project/app/.myapp (highest precedence)
  Level 1: /project/.myapp (lowest precedence)

RESOLVED CONFIGURATION WITH SOURCES:
Format: [Source] key: value

[Level 0: app            ] host                : "localhost"
[Level 1: project        ] port                : 3000
[Array merge (append)    ] features            : ["auth", "logging", "debug"]
  ‚Ü≥ Level 1: project     :   ["auth", "logging"]
  ‚Ü≥ Level 0: app         :   ["debug"]
[Array merge (prepend)   ] excludePatterns     : ["*.debug", "*.tmp", "*.log"]
  ‚Ü≥ Level 0: app         :   ["*.debug"] (prepended)
  ‚Ü≥ Level 1: project     :   ["*.tmp", "*.log"]

--------------------------------------------------------------------------------
SUMMARY:
  Total configuration keys: 4
  Configuration sources: 2
  Array merge operations: 2
  Values by source:
    Level 0: app: 2 value(s)
    Level 1: project: 2 value(s)
================================================================================
```

### Output Features

- **Source tracking**: Shows exactly which file provided each value
- **Hierarchical visualization**: Displays precedence levels clearly
- **CLI argument tracking**: Shows values overridden by command line
- **Array merge insight**: Details how arrays are combined in hierarchical mode
- **Schema defaults**: Identifies values from schema defaults
- **Summary statistics**: Overview of configuration sources

### Programmatic Usage

```typescript
// Analyze configuration programmatically
await cardigantime.checkConfig(args);

// This will display the analysis and exit the process
```

## Debugging Common Issues

### Configuration Validation Failures

When you get validation errors, use this systematic approach:

#### Step 1: Generate Reference Configuration

```bash
# Generate a valid configuration to see the expected structure
./myapp --init-config
```

This shows you:
- All required fields
- Correct field names (catch typos)
- Expected data types
- Default values

#### Step 2: Check Current Configuration

```bash
# See what your current configuration resolves to
./myapp --check-config
```

This shows you:
- Which file is providing each value
- If CLI arguments are overriding file values
- Whether hierarchical merging is working correctly

#### Step 3: Compare and Fix

Compare the generated reference with your current configuration to identify:
- **Typos in field names** (e.g., `databse` instead of `database`)
- **Wrong data types** (e.g., string instead of number)
- **Missing required fields**
- **Invalid values** (e.g., invalid URLs, out-of-range numbers)

### Example Debugging Session

**Problem:** Validation error about invalid port number

```bash
$ ./myapp
‚ùå Configuration validation failed: port must be between 1 and 65535

# Step 1: Check what's expected
$ ./myapp --init-config
# Shows: port: 3000

# Step 2: Check current configuration
$ ./myapp --check-config
[config.yaml             ] port                : "3000"

# Problem identified: port is a string, should be number
```

**Fix:** Update configuration file:
```yaml
# Before (wrong)
port: "3000"

# After (correct)  
port: 3000
```

### Hierarchical Configuration Issues

#### Array Merging Problems

**Problem:** Arrays not merging as expected

```typescript
// Configuration
fieldOverlaps: {
  'features': 'append'
}
```

**Debug with `--check-config`:**
```bash
$ ./myapp --check-config

[Array merge (append)    ] features            : ["auth", "logging", "debug"]
  ‚Ü≥ Level 1: project     :   ["auth", "logging"]
  ‚Ü≥ Level 0: app         :   ["debug"]
```

This shows exactly how arrays are being merged and from which levels.

#### Precedence Problems

**Problem:** Values not being overridden as expected

```bash
$ ./myapp --database-host prod.db.example.com --check-config

[Level 0: myproject      ] database.host       : "localhost"
[CLI argument            ] database.host       : "prod.db.example.com"  # ‚ùå Should win
```

This indicates the CLI argument parsing might have an issue.

### Path Resolution Debugging

When using `pathResolution` options, verify paths are being resolved correctly:

```bash
$ ./myapp --check-config

[config.yaml             ] outputDir           : "./config/build"     # ‚úÖ Resolved
[config.yaml             ] logFile             : "./logs/app.log"     # ‚úÖ Resolved  
[config.yaml             ] absolutePath        : "/usr/bin/tool"      # ‚úÖ Unchanged
```

**Common path resolution issues:**

1. **Path not being resolved**: Check if field is in `pathFields` array
2. **Array elements not resolved**: Check if field is in `resolvePathArray`
3. **Wrong base directory**: Verify config file location

### CLI Option Issues

#### Options Not Working

**Problem:** CLI options not overriding configuration

**Debug checklist:**
1. Ensure `await cardigantime.configure(program)` is called before `program.parse()`
2. Check option naming: nested keys use dashes (e.g., `--database-host`)
3. Verify option types match schema (use `parseInt` for numbers)

```typescript
// ‚ùå Wrong
program.option('--port <port>', 'Server port')

// ‚úÖ Correct  
program.option('--port <port>', 'Server port', parseInt)
```

#### Option Name Mapping

Cardigantime automatically converts config keys to CLI options:

```typescript
// Config structure
{
  database: {
    host: "localhost",
    maxConnections: 10
  }
}

// Generated CLI options
// --database-host <host>
// --database-max-connections <connections>
```

Use `--help` to see all available options:
```bash
./myapp --help
```

## Troubleshooting Workflow

### Systematic Debugging Process

1. **Identify the problem**
   - Configuration validation error?
   - Value not being set correctly?
   - CLI option not working?

2. **Generate reference configuration**
   ```bash
   ./myapp --init-config
   ```

3. **Analyze current configuration**
   ```bash
   ./myapp --check-config
   ```

4. **Compare and identify issues**
   - Field name typos
   - Data type mismatches
   - Precedence problems
   - Path resolution issues

5. **Fix and verify**
   - Make corrections
   - Re-run `--check-config` to verify

### Common Error Patterns

#### "Unknown configuration keys found"

```bash
$ ./myapp --check-config
‚ùå Unknown configuration keys found: databse
üí° Did you mean: database

# Check your configuration file for typos
```

#### "Configuration validation failed"

```bash
$ ./myapp
‚ùå Configuration validation failed: Expected number, received string

# Use --check-config to see which field has the wrong type
$ ./myapp --check-config
[config.yaml             ] port                : "3000"  # Should be number
```

#### "Config directory does not exist"

```bash
$ ./myapp
‚ùå Config directory does not exist and is required: ./nonexistent

# Solutions:
mkdir -p ./nonexistent
# OR
./myapp --config-directory ./existing-dir  
# OR
# Set isRequired: false in configuration
```

### Performance Analysis

For large configurations or complex hierarchical setups:

#### Configuration Loading Time

```typescript
console.time('config-load');
const config = await cardigantime.read(args);
console.timeEnd('config-load');
```

#### Memory Usage

```typescript
const used = process.memoryUsage();
console.log('Memory usage:', {
  rss: Math.round(used.rss / 1024 / 1024) + ' MB',
  heapTotal: Math.round(used.heapTotal / 1024 / 1024) + ' MB',
  heapUsed: Math.round(used.heapUsed / 1024 / 1024) + ' MB'
});
```

## Advanced Debugging Techniques

### Custom Logger for Debugging

```typescript
import winston from 'winston';

const debugLogger = winston.createLogger({
  level: 'debug', // Enable debug logs
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.printf(({ timestamp, level, message }) => {
      return `${timestamp} [${level}]: ${message}`;
    })
  ),
  transports: [
    new winston.transports.Console(),
    new winston.transports.File({ filename: 'cardigantime-debug.log' })
  ]
});

cardigantime.setLogger(debugLogger);
```

### Environment Variable Debugging

```bash
# Enable debug logging
DEBUG=cardigantime:* ./myapp

# Check environment variables
NODE_ENV=development ./myapp --check-config
```

### Schema Validation Debugging

```typescript
try {
  await cardigantime.validate(config);
} catch (error) {
  if (error instanceof ConfigurationError) {
    console.log('Error type:', error.errorType);
    console.log('Details:', JSON.stringify(error.details, null, 2));
    console.log('Config path:', error.configPath);
  }
}
```

This comprehensive debugging approach will help you quickly identify and resolve configuration issues in your Cardigantime setup. 